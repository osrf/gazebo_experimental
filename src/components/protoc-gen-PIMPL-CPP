#!/usr/bin/env python

import copy
import os
import sys

file_path = os.path.dirname(os.path.realpath(__file__))

try:
    from google.protobuf.compiler import plugin_pb2 as plugin
    from google.protobuf.descriptor import FieldDescriptor
    from google.protobuf.descriptor_pb2 import DescriptorProto
    from google.protobuf.descriptor_pb2 import EnumDescriptorProto
except ImportError:
    sys.stderr.write("""\n\nNeed python protobuf libraries: 
        Do `pip install protobuf` or `apt install python-protobuf`
        
        """)
    raise


# nested types that can be swapped for simple types
known_complex_types = {
        ".gazebo.components.Vector3d": {
            "type": "ignition::math::Vector3d",
            "include": "ignition/math/Vector3.hh",
            "default": None,
            },
        ".gazebo.components.Quaterniond": {
            "type": "ignition::math::Quaterniond",
            "include": "ignition/math/Quaternion.hh",
            "default": None,
            },
        ".gazebo.components.Pose3d": {
            "type": "ignition::math::Pose3d",
            "include": "ignition/math/Pose3.hh",
            "default": None,
            },
        }


# Known complex types get swapped out, no need to include api files for them
ignore_dependencies = [
        "gazebo/components/Vector3d.proto",
        "gazebo/components/Quaterniond.proto",
        "gazebo/components/Pose3d.proto",
        ]


# Map protobuf simple types to c++ types
simple_types_to_cpp = {
        FieldDescriptor.TYPE_DOUBLE: "double",
        FieldDescriptor.TYPE_FLOAT: "float",
        FieldDescriptor.TYPE_INT64: "int64_t",
        FieldDescriptor.TYPE_UINT64: "uint64_t",
        FieldDescriptor.TYPE_INT32: "int32_t",
        FieldDescriptor.TYPE_FIXED64: "uint64_t",
        FieldDescriptor.TYPE_FIXED32: "uint32_t",
        FieldDescriptor.TYPE_BOOL: "bool",
        FieldDescriptor.TYPE_STRING: "std::string",
        FieldDescriptor.TYPE_BYTES: "std::string",
        FieldDescriptor.TYPE_UINT32: "uint32_t",
        FieldDescriptor.TYPE_SFIXED32: "int32_t",
        FieldDescriptor.TYPE_SFIXED64: "int64_t",
        FieldDescriptor.TYPE_SINT32: "int32_t",
        FieldDescriptor.TYPE_SINT64: "int64_t",
        }


factory_cc_template = None
with open(file_path + "/templates/Factory.cc.in", "r") as fin:
    factory_cc_template = fin.read()


fw_decl_hh_template = None
with open(file_path + "/templates/ForwardDeclaration.hh.in", "r") as fin:
    fw_decl_hh_template = fin.read()


api_hh_template = None
with open(file_path + "/templates/Api.hh.in", "r") as fin:
    api_hh_template = fin.read()


api_cc_template = None
with open(file_path + "/templates/Api.cc.in", "r") as fin:
    api_cc_template = fin.read()


class_decl_template = None
with open(file_path + "/templates/class_decl.hh.in", "r") as fin:
    class_decl_template = fin.read()


class_def_template = None
with open(file_path + "/templates/class_def.cc.in", "r") as fin:
    class_def_template = fin.read()


storage_hh_template = None
with open(file_path + "/templates/Storage.hh.in", "r") as fin:
    storage_hh_template = fin.read()

storage_decl_template = None
with open(file_path + "/templates/storage_decl.hh.in", "r") as fin:
    storage_decl_template = fin.read()

declaration_template = None
with open(file_path + "/templates/ApiDeclaration.hh.in", "r") as fin:
    declaration_template = fin.read()


definition_template = None
with open(file_path + "/templates/ApiDefinition.cc.in", "r") as fin:
    definition_template = fin.read()


complex_definition_template = None
with open(file_path + "/templates/ApiComplexDefinition.cc.in", "r") as fin:
    complex_definition_template = fin.read()


field_template = None
with open(file_path + "/templates/StorageField.cc.in", "r") as fin:
    field_template = fin.read()


field_with_default_template = None
with open(file_path + "/templates/StorageFieldWithDefault.cc.in", "r") as fin:
    field_with_default_template = fin.read()


include_template = None
with open(file_path + "/templates/Include.hh.in", "r") as fin:
    include_template = fin.read()


enum_template = None
with open(file_path + "/templates/Enum.hh.in", "r") as fin:
    enum_template = fin.read()


enum_field_template = None
with open(file_path + "/templates/EnumField.hh.in", "r") as fin:
    enum_field_template = fin.read()


def generate_enum(indent, enum_dict):
    """Generate a single enum given a dict of values
    @param indent is whitespace to indent the enum
    @param enum_dict is a dictionary with info about the num
    @returns a string with the generted C++ code
    """
    # Generate code for individual values in enum
    gen_fields = []
    for field in enum_dict["fields"]:
        gen_field = enum_field_template
        gen_field = (gen_field.replace("%%ns_indent%%", indent)
                             .replace("%%field_name%%", field["name"])
                             .replace("%%field_number%%",
                                      str(field["number"])))
        gen_fields.append(gen_field)
    gen_fields = "".join(gen_fields)
    # combine value into a larger enum type
    gen_enum_hh = enum_template
    gen_enum_hh = (gen_enum_hh.replace("%%ns_indent%%", indent)
                             .replace("%%enum_name%%", enum_dict["name"])
                             .replace("%%enum_fields%%", gen_fields))
    return gen_enum_hh


def generate_namespace(package):
    """Generates odd bits of C++ code based on a period delimited string
    @returns tuple
        ns_indent (whitespace to indent code)
        full_namespace (c++ namespace using ::)
        ns_begin (start of namespace block)
        ns_end (end of namespace block)
    """
    # discard empty pieces (leading dot)
    namespaces = [piece for piece in package.split(".") if piece]
    full_namespace = "::".join(namespaces)
    ns_indent = "  " * len(namespaces)
    ns_begin = ""
    ns_end = ""
    for x, ns in enumerate(namespaces):
        indent = "  " * x
        ns_begin += "\n{indent}namespace {ns}\n{indent}{{".format(
                indent=indent, ns=ns)
        ns_end = "{indent}}}\n".format(indent=indent) + ns_end
    return (ns_indent, full_namespace, ns_begin, ns_end)


def generate_class_pieces(package, component_name, simple_fields, enumerations,
        complex_fields):
    """Generates C++ code for pieces of a class
    @param package a dot delimited string
    @param component_name string name of component
    @param simple_fields dict with info about fields in message
    @enumerations dict with info about inline enumerations
    @param complex_fields list with info about fields that are messages
    @returns dict
        api_definitions list with C++ api defintions
        api_declarations list with C++ api declarations
        enum_types list with C++ enum declarations
        hh_includes set with C++ includes
    """
    # generate c++ namespace from protobuf package
    (ns_indent, full_namespace,
            ns_begin, ns_end) = generate_namespace(package)

    api_definitions = []
    api_declarations = []
    enum_types = []
    hh_includes = set()

    # Generate code for enum types
    for enum in enumerations:
        enum_types.append(generate_enum(ns_indent, enum))

    # Generate code for simple fields
    for field in simple_fields:
        api_doxygen = (ns_indent
                + r"  /// \brief Get reference to "
                + field["name"])

        field_type = field["type"] + " &"

        declaration = declaration_template
        declaration = (declaration.replace("%%field_type%%", field_type)
                                  .replace("%%field_name%%", field["name"])
                                  .replace("%%ns_indent%%", ns_indent)
                                  .replace("%%api_doxygen%%", api_doxygen))
        api_declarations.append(declaration)

        definition = definition_template
        definition = (definition.replace("%%field_type%%", field_type)
                                .replace("%%field_name%%", field["name"])
                                .replace("%%ns_indent%%", ns_indent)
                                .replace("%%full_namespace%%", full_namespace)
                                .replace("%%component_name%%", component_name))
        api_definitions.append(definition)

        if field["include"]:
            include = include_template
            include = include.replace("%%include%%", field["include"])
            hh_includes.add(include)

    # Generate code for complex fields
    for field in complex_fields:
        api_doxygen = (ns_indent
                + r"  /// \brief Get accessor to "
                + field["name"])
        field_type = field["type"] + " "
        declaration = declaration_template
        declaration = (declaration.replace("%%field_type%%", field_type)
                                  .replace("%%field_name%%", field["name"])
                                  .replace("%%ns_indent%%", ns_indent)
                                  .replace("%%api_doxygen%%", api_doxygen))
        api_declarations.append(declaration)

        definition = complex_definition_template
        definition = (definition.replace("%%field_type%%", field_type)
                                .replace("%%field_name%%", field["name"])
                                .replace("%%ns_indent%%", ns_indent)
                                .replace("%%full_namespace%%", full_namespace)
                                .replace("%%component_name%%", component_name))
        api_definitions.append(definition)

    return {
            "api_definitions": api_definitions,
            "api_declarations": api_declarations,
            "enum_types": enum_types,
            "hh_includes": hh_includes,
            }


def generate_class_partial(decl_template, def_template, package, class_name,
        simple_fields, enumerations, complex_fields, inline_nested_names,
        nested_types):
    """Generates part of class declaration
    @param decl_template class declaration template
    @param def_template class definition template
    @param package a dot delimited string
    @param class_name string name of class
    @param simple_fields dict with info about fields in message
    @enumerations dict with info about inline enumerations
    @param complex_fields list with info about fields that are messages
    @param inline_nested_names list of names defined in top-level message
    @param nested_types dict of types that are defined inline
    @returns dict
        hh_includes set of headers that need to be included
        class_decl string C++ code with class declaration
        class_def string C++ code with class declaration
    """
    # generate c++ namespace from protobuf package
    (ns_indent, full_namespace,
            ns_begin, ns_end) = generate_namespace(package)

    class_pieces = generate_class_pieces(package, class_name,
            simple_fields, enumerations, complex_fields)

    inline_decl = []
    inline_def = []
    hh_includes = class_pieces["hh_includes"]

    for nested_name in inline_nested_names:
        # Recursively generate nested messages
        nested_info = nested_types[nested_name]
        nested_package = ".".join(nested_name.split(".")[:-1])
        nested_partial = generate_class_partial(class_decl_template,
                class_def_template, nested_package, nested_info["name"],
                nested_info["simple_fields"], nested_info["enumerations"],
                nested_info["complex_fields"], nested_info["nested_types"],
                nested_types)
        hh_includes.update(nested_partial["hh_includes"])
        inline_decl.append(nested_partial["class_decl"])
        inline_def.append(nested_partial["class_def"])

    api_definitions = "\n".join(class_pieces["api_definitions"])
    api_declarations = "\n".join(class_pieces["api_declarations"])
    inline_decl = "\n".join(inline_decl)
    inline_def = "\n".join(inline_def)
    enum_types = "\n".join(class_pieces["enum_types"])

    # Put all content together
    hh_content = decl_template
    hh_content = (hh_content.replace("%%class_name%%", class_name)
                            .replace("%%ns_indent%%", ns_indent)
                            .replace("%%api_declarations%%", api_declarations)
                            .replace("%%inline_declarations%%", inline_decl)
                            .replace("%%enumerations%%", enum_types))

    cc_content = def_template
    cc_content = (cc_content.replace("%%class_name%%", class_name)
                            .replace("%%ns_indent%%", ns_indent)
                            .replace("%%full_namespace%%", full_namespace)
                            .replace("%%inline_definitions%%", inline_def)
                            .replace("%%api_definitions%%", api_definitions))
    return {
            "hh_includes": hh_includes,
            "class_decl": hh_content,
            "class_def": cc_content}


def generate_api_files(dependency, package, component_name, simple_fields,
        enumerations, complex_fields, inline_nested_names, nested_types):
    """Generates header and source file for API
    @param dependency iterable of strings of protofiles
    @param package a dot delimited string
    @param component_name string name of component
    @param simple_fields dict with info about fields in message
    @enumerations dict with info about inline enumerations
    @param complex_fields list with info about fields that are messages
    @param inline_nested_names list of names defined in top-level message
    @param nested_types dict of types that are defined inline
    @returns tuple
        string with header file
        string with source file
    """
    # generate c++ namespace from protobuf package
    (ns_indent, full_namespace,
            ns_begin, ns_end) = generate_namespace(package)

    hh_includes = set()

    # Includes for dependencies
    for dep in dependency:
        #discard ".proto"
        pieces = dep.split(".")[:-1]
        base_include = "/".join(pieces)
        hh_include = include_template.replace("%%include%%",
                base_include + ".api.hh")
        hh_includes.add(hh_include)

    partial_cpp = generate_class_partial(api_hh_template, api_cc_template,
            package, component_name, simple_fields, enumerations,
            complex_fields, inline_nested_names, nested_types);
    hh_includes.update(partial_cpp["hh_includes"])

    hh_includes = "".join(hh_includes)

    # Put all content together
    hh_content = partial_cpp["class_decl"]
    hh_content = (hh_content.replace("%%full_namespace%%", full_namespace)
                            .replace("%%ns_begin%%", ns_begin)
                            .replace("%%ns_end%%", ns_end)
                            .replace("%%includes%%", hh_includes))

    cc_content = partial_cpp["class_def"]
    cc_content = (cc_content.replace("%%component_name%%", component_name)
                            .replace("%%full_namespace%%", full_namespace)
                            .replace("%%ns_begin%%", ns_begin)
                            .replace("%%ns_end%%", ns_end))
    return hh_content, cc_content


def generate_storage_header(dependency, package, component_name, simple_fields,
        complex_fields, nested_types):
    """Generates header for storage class
    @param dependency iterable of strings of protofiles
    @param package a dot delimited string
    @param component_name string name of component
    @param simple_fields dict with info about fields in message
    @param complex_fields list with info about fields that are messages
    @returns string with header file
    """
    # generate c++ namespace from protobuf package
    (ns_indent, full_namespace,
            ns_begin, ns_end) = generate_namespace(package)
    storage_doxygen = (ns_indent
            + r"/// \brief Generated storage class for component "
            + component_name)

    storage_fields = []
    for field in simple_fields:
        field_doxygen = ns_indent + r"  /// \brief holds " + field["name"]
        storage_field = field_template
        if field["default"]:
            storage_field = field_with_default_template
            storage_field = storage_field.replace(
                    "%%field_default%%", field["default"])
        storage_field = (storage_field.replace("%%field_doxygen%%", field_doxygen)
                                      .replace("%%field_type%%", field["type"])
                                      .replace("%%field_name%%", field["name"])
                                      .replace("%%ns_indent%%", ns_indent))
        storage_fields.append(storage_field)

    for field in complex_fields:
        field_doxygen = ns_indent + r"  /// \brief holds " + field["name"]
        storage_field = field_template
        field_type = field["type"] + "Storage"
        storage_field = (storage_field.replace("%%field_doxygen%%", field_doxygen)
                                      .replace("%%field_type%%", field_type)
                                      .replace("%%field_name%%", field["name"])
                                      .replace("%%ns_indent%%", ns_indent))
        storage_fields.append(storage_field)

    storage_fields = "\n".join(storage_fields)

    includes = set()
    for dep in dependency:
        #discard ".proto"
        pieces = dep.split(".")[:-1]
        base_include = "/".join(pieces)
        include = include_template.replace("%%include%%",
                base_include + ".storage.hh")
        includes.add(include)

    includes = "".join(includes)

    hh_content = storage_hh_template
    hh_content = (hh_content.replace("%%component_name%%", component_name)
                            .replace("%%full_namespace%%", full_namespace)
                            .replace("%%ns_begin%%", ns_begin)
                            .replace("%%ns_end%%", ns_end)
                            .replace("%%ns_indent%%", ns_indent)
                            .replace("%%includes%%", includes)
                            .replace("%%storage_doxygen%%", storage_doxygen)
                            .replace("%%storage_fields%%", storage_fields))
    return hh_content


def generate_factory_cc(package, component_name):
    """Generates cc file with factory class
    @param package string dot delimited
    @param component_name string name of component
    @returns string content of factory .cc file
    """
    (ns_indent, full_namespace,
            ns_begin, ns_end) = generate_namespace(package)
    factory_doxygen = (ns_indent
            + r"/// \brief Generated Factory class for component "
            + component_name)
    cc_content = factory_cc_template
    cc_content = (cc_content.replace("%%component_name%%", component_name)
                            .replace("%%full_namespace%%", full_namespace)
                            .replace("%%ns_begin%%", ns_begin)
                            .replace("%%ns_end%%", ns_end)
                            .replace("%%ns_indent%%", ns_indent)
                            .replace("%%factory_doxygen%%", factory_doxygen))
    return cc_content


def gather_message_info(package, message_descriptor, nested_types):
    """Given a MessageDescriptor, get required info from it
    @param package string dot delimited
    @param message_descriptor MessageDescriptor
    @param nested_types dict mapping full type name to nested message info
                        (this dict will be modified)
    @returns dict
        package dot delimited string indicating namespace
        name string of message name
        enumerations list of info about inline enumerations
        simple_fields list of info about simple fields
        complex_fields list of info about complex fields
        nested_types list of string identifying nested types in this message
    """
    enumerations = []
    simple_fields = []
    complex_fields = []
    inline_nested_names = []
    component_name = message_descriptor.name

    # Recursively get info from nested messages
    for nested_descriptor in message_descriptor.nested_type:
        if package and package[0] != ".":
            package = "." + package
        nested_package = ".".join([package, component_name])
        type_name = ".".join([nested_package, nested_descriptor.name])
        nested_types[type_name] = gather_message_info(
                nested_package, nested_descriptor, nested_types)
        inline_nested_names.append(type_name)

    # Pull enumerations out of message
    for enum_descriptor in message_descriptor.enum_type:
        enum = {}
        enum["name"] = enum_descriptor.name
        enum["fields"] = []
        for value_descriptor in enum_descriptor.value:
            field = {}
            field["name"] = value_descriptor.name
            field["number"] = value_descriptor.number
            enum["fields"].append(field)
        enumerations.append(enum)

    # Pull info about fields from the message
    for field_descriptor in message_descriptor.field:
        if field_descriptor.type == FieldDescriptor.TYPE_MESSAGE:
            # Complex/Nested type
            if field_descriptor.type_name in known_complex_types:
                # Swap complex type for a simple type
                field = copy.deepcopy(
                    known_complex_types[field_descriptor.type_name])
                field["name"] = field_descriptor.name
                simple_fields.append(field)
            else:
                field = {}
                field["type"] = field_descriptor.type_name.replace(".", "::")
                field["name"] = field_descriptor.name
                complex_fields.append(field)
        elif FieldDescriptor.TYPE_ENUM == field_descriptor.type:
            field = {}
            field["include"] = None
            field["name"] = field_descriptor.name
            field["type"] = field_descriptor.type_name.replace(".", "::")
            field["default"] = "static_cast<" + field["type"] + ">(0)"
            simple_fields.append(field)
        else:
            # Simple type
            field = {}
            field["include"] = None
            field["name"] = field_descriptor.name
            field["type"] = simple_types_to_cpp[field_descriptor.type]
            default = field_descriptor.default_value
            if ( FieldDescriptor.TYPE_STRING == field_descriptor.type or
                    FieldDescriptor.TYPE_BYTES == field_descriptor.type ):
                field["default"] = '"' + default + '"'
            else:
                field["default"] = default
            simple_fields.append(field)

    return {"package": package,
            "name": component_name,
            "enumerations": enumerations,
            "simple_fields": simple_fields,
            "complex_fields": complex_fields,
            "nested_types": inline_nested_names,
            }


def generate_message_files(dependency, package, message_descriptor):
    """Given a MessageDescriptor, get required info and generate two headers
    for this message
    @param dependency iterable of strings of imported files
    @param package string dot delimited
    @param message_descriptor MessageDescriptor
    @returns tuple
        api_header string with C++ code for api class
        api_source string with C++ code for api implementation
        storage_header string with c++ code for storage class
    """

    nested_types = {}
    info = gather_message_info(package, message_descriptor, nested_types)

    dependency = [dep for dep in dependency if dep not in ignore_dependencies]

    # Generate code with the information gathered
    api_header, api_source = generate_api_files(dependency, info["package"],
            info["name"], info["simple_fields"], info["enumerations"],
            info["complex_fields"], info["nested_types"], nested_types)

    storage_header = generate_storage_header(dependency, info["package"],
            info["name"], info["simple_fields"], info["complex_fields"],
            info["nested_types"])

    return api_header, api_source, storage_header


def generate_code(request, response):
    """Given a CodeGeneratorRequest and CodeGeneratorResponse,
    generate C++ code that fulfills the Factory/API/Storage separation
    required of ECS components"""
    # Loop through included protobuf fields
    for proto_file in request.proto_file:
        # Support only one top-level message per file
        if len(proto_file.message_type) != 1:
            sys.stderr.write("Must be exactly one top-level message per file")
            sys.exit(42)

        message_descriptor = proto_file.message_type[0]
        component_name = message_descriptor.name

        api_header, api_source, storage_header = generate_message_files(
                proto_file.dependency, proto_file.package, message_descriptor)

        factory_cc = generate_factory_cc(proto_file.package, component_name)

        base_filename = proto_file.name.split(".")[0]

        api_hh_file = response.file.add()
        api_hh_file.name = base_filename + ".api.hh"
        api_hh_file.content = api_header

        api_cc_file = response.file.add()
        api_cc_file.name = base_filename + ".api.cc"
        api_cc_file.content = api_source

        storage_hh_file = response.file.add()
        storage_hh_file.name = base_filename + ".storage.hh"
        storage_hh_file.content = storage_header

        factory_cc_file = response.file.add()
        factory_cc_file.name = base_filename + ".factory.cc"
        factory_cc_file.content = factory_cc


if __name__ == '__main__':
    # Read request message from stdin
    data = sys.stdin.read()

    # Parse request
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Create response
    response = plugin.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Serialise response message
    output = response.SerializeToString()

    # Write to stdout
    sys.stdout.write(output)
