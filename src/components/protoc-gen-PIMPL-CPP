#!/usr/bin/env python

import copy
import os
import sys

file_path = os.path.dirname(os.path.realpath(__file__))

try:
    from google.protobuf.compiler import plugin_pb2 as plugin
    from google.protobuf.descriptor import FieldDescriptor
    from google.protobuf.descriptor_pb2 import DescriptorProto
    from google.protobuf.descriptor_pb2 import EnumDescriptorProto
except ImportError:
    sys.stderr.write("""\n\nNeed python protobuf libraries: 
        Do `pip install protobuf` or `apt install python-protobuf`
        
        """)
    raise


# nested types that can be swapped for simple types
known_nested_types = {
        ".gazebo.components.Vector3d": {
            "type": "ignition::math::Vector3d",
            "include": "ignition/math/Vector3.hh",
            "space": " ",
            "default": None,
            },
        ".gazebo.components.Quaterniond": {
            "type": "ignition::math::Quaterniond",
            "include": "ignition/math/Quaternion.hh",
            "space": " ",
            "default": None,
            },
        ".gazebo.components.Pose3d": {
            "type": "ignition::math::Pose3d",
            "include": "ignition/math/Pose3.hh",
            "space": " ",
            "default": None,
            },
        }


# Map protobuf simple types to c++ types
simple_types_to_cpp = {
        FieldDescriptor.TYPE_DOUBLE: "double",
        FieldDescriptor.TYPE_FLOAT: "float",
        FieldDescriptor.TYPE_INT64: "int64_t",
        FieldDescriptor.TYPE_UINT64: "uint64_t",
        FieldDescriptor.TYPE_INT32: "int32_t",
        FieldDescriptor.TYPE_FIXED64: "uint64_t",
        FieldDescriptor.TYPE_FIXED32: "uint32_t",
        FieldDescriptor.TYPE_BOOL: "bool",
        FieldDescriptor.TYPE_STRING: "std::string",
        FieldDescriptor.TYPE_BYTES: "std::string",
        FieldDescriptor.TYPE_UINT32: "uint32_t",
        FieldDescriptor.TYPE_SFIXED32: "int32_t",
        FieldDescriptor.TYPE_SFIXED64: "int64_t",
        FieldDescriptor.TYPE_SINT32: "int32_t",
        FieldDescriptor.TYPE_SINT64: "int64_t",
        }


factory_cc_template = None
with open(file_path + "/templates/Factory.cc.in", "r") as fin:
    factory_cc_template = fin.read()


api_hh_template = None
with open(file_path + "/templates/Api.hh.in", "r") as fin:
    api_hh_template = fin.read()


api_cc_template = None
with open(file_path + "/templates/Api.cc.in", "r") as fin:
    api_cc_template = fin.read()


storage_hh_template = None
with open(file_path + "/templates/Storage.hh.in", "r") as fin:
    storage_hh_template = fin.read()


declaration_template = None
with open(file_path + "/templates/ApiDeclaration.hh.in", "r") as fin:
    declaration_template = fin.read()


definition_template = None
with open(file_path + "/templates/ApiDefinition.cc.in", "r") as fin:
    definition_template = fin.read()


field_template = None
with open(file_path + "/templates/StorageField.cc.in", "r") as fin:
    field_template = fin.read()


field_with_default_template = None
with open(file_path + "/templates/StorageFieldWithDefault.cc.in", "r") as fin:
    field_with_default_template = fin.read()


include_template = None
with open(file_path + "/templates/Include.hh.in", "r") as fin:
    include_template = fin.read()


enum_template = None
with open(file_path + "/templates/Enum.hh.in", "r") as fin:
    enum_template = fin.read()


enum_field_template = None
with open(file_path + "/templates/EnumField.hh.in", "r") as fin:
    enum_field_template = fin.read()


def generate_enum(indent, enum_dict):
    """Generate a single enum given a dict of values
    @param indent is whitespace to indent the enum
    @param enum_dict is a dictionary with info about the num
    @returns a string with the generted C++ code
    """
    # Generate code for individual values in enum
    gen_fields = []
    for field in enum_dict["fields"]:
        gen_field = enum_field_template
        gen_field = (gen_field.replace("%%ns_indent%%", indent)
                             .replace("%%field_name%%", field["name"])
                             .replace("%%field_number%%",
                                      str(field["number"])))
        gen_fields.append(gen_field)
    gen_fields = "".join(gen_fields)
    # combine value into a larger enum type
    gen_enum_hh = enum_template
    gen_enum_hh = (gen_enum_hh.replace("%%ns_indent%%", indent)
                             .replace("%%enum_name%%", enum_dict["name"])
                             .replace("%%enum_fields%%", gen_fields))
    return gen_enum_hh


def generate_namespace(package):
    """Generates odd bits of C++ code based on a period delimited string
    @returns tuple
        ns_indent (whitespace to indent code)
        full_namespace (c++ namespace using ::)
        ns_begin (start of namespace block)
        ns_end (end of namespace block)
    """
    namespaces = package.split(".")
    full_namespace = "::".join(namespaces)
    ns_indent = "  " * len(namespaces)
    ns_begin = ""
    ns_end = ""
    for x, ns in enumerate(namespaces):
        indent = "  " * x
        ns_begin += "\n{indent}namespace {ns}\n{indent}{{".format(
                indent=indent, ns=ns)
        ns_end = "{indent}}}\n".format(indent=indent) + ns_end
    return (ns_indent, full_namespace, ns_begin, ns_end)


def generate_api_files(package, component_name, simple_fields, enumerations):
    """Generates header and source file for API
    @param package a dot delimited string
    @param component_name string name of component
    @param simple_fields dict with info about fields in message
    @enumerations dict with info about inline enumerations
    @returns tuple
        string with header file
        string with source file
    """
    # generate c++ namespace from protobuf package
    (ns_indent, full_namespace,
            ns_begin, ns_end) = generate_namespace(package)

    api_definitions = []
    api_declarations = []
    enum_types = []
    includes = set()

    # Generate code for enum types
    for enum in enumerations:
        enum_types.append(generate_enum(ns_indent, enum))

    # Generate code for simple fields
    for field in simple_fields:
        api_doxygen = (ns_indent
                + r"  /// \brief Get reference to "
                + field["name"])

        declaration = declaration_template
        declaration = (declaration.replace("%%field_type%%", field["type"])
                                  .replace("%%field_name%%", field["name"])
                                  .replace("%%ns_indent%%", ns_indent)
                                  .replace("%%api_doxygen%%", api_doxygen))
        api_declarations.append(declaration)

        definition = definition_template
        definition = (definition.replace("%%field_type%%", field["type"])
                                .replace("%%field_name%%", field["name"])
                                .replace("%%ns_indent%%", ns_indent)
                                .replace("%%component_name%%", component_name))
        api_definitions.append(definition)

        if len(field["include"]):
            include = include_template
            include = include.replace("%%include%%", field["include"])
            includes.add(include)

    api_definitions = "\n".join(api_definitions)
    api_declarations = "\n".join(api_declarations)
    enum_types = "\n".join(enum_types)
    includes = "".join(includes)

    # Put all content together
    hh_content = api_hh_template
    hh_content = (hh_content.replace("%%component_name%%", component_name)
                            .replace("%%full_namespace%%", full_namespace)
                            .replace("%%ns_begin%%", ns_begin)
                            .replace("%%ns_end%%", ns_end)
                            .replace("%%ns_indent%%", ns_indent)
                            .replace("%%includes%%", includes)
                            .replace("%%api_declarations%%", api_declarations)
                            .replace("%%enumerations%%", enum_types))

    cc_content = api_cc_template
    cc_content = (cc_content.replace("%%component_name%%", component_name)
                            .replace("%%full_namespace%%", full_namespace)
                            .replace("%%ns_begin%%", ns_begin)
                            .replace("%%ns_end%%", ns_end)
                            .replace("%%ns_indent%%", ns_indent)
                            .replace("%%api_definitions%%", api_definitions))
    return hh_content, cc_content


def generate_storage_header(package, component_name, simple_fields):
    """Generates header for storage class
    @param package a dot delimited string
    @param component_name string name of component
    @param simple_fields dict with info about fields in message
    @returns string with header file
    """
    # generate c++ namespace from protobuf package
    (ns_indent, full_namespace,
            ns_begin, ns_end) = generate_namespace(package)
    storage_doxygen = (ns_indent
            + r"/// \brief Generated storage class for component "
            + component_name)

    storage_fields = []
    for field in simple_fields:
        field_doxygen = ns_indent + r"  /// \brief holds " + field["name"]
        api_doxygen = ns_indent + r"  /// \brief Get reference to " + field["name"]
        
        storage_field = field_template
        if field["default"]:
            storage_field = field_with_default_template
            storage_field = storage_field.replace(
                    "%%field_default%%", field["default"])
        storage_field = (storage_field.replace("%%field_doxygen%%", field_doxygen)
                                      .replace("%%field_type%%", field["type"])
                                      .replace("%%field_space%%", field["space"])
                                      .replace("%%field_name%%", field["name"])
                                      .replace("%%ns_indent%%", ns_indent))
        storage_fields.append(storage_field)
    storage_fields = "\n".join(storage_fields)

    hh_content = storage_hh_template
    hh_content = (hh_content.replace("%%component_name%%", component_name)
                            .replace("%%full_namespace%%", full_namespace)
                            .replace("%%ns_begin%%", ns_begin)
                            .replace("%%ns_end%%", ns_end)
                            .replace("%%ns_indent%%", ns_indent)
                            .replace("%%storage_doxygen%%", storage_doxygen)
                            .replace("%%storage_fields%%", storage_fields))
    return hh_content


def generate_factory_cc(package, component_name):
    """Generates cc file with factory class
    @param package string dot delimited
    @param component_name string name of component
    @returns string content of factory .cc file
    """
    (ns_indent, full_namespace,
            ns_begin, ns_end) = generate_namespace(package)
    factory_doxygen = (ns_indent
            + r"/// \brief Generated Factory class for component "
            + component_name)
    cc_content = factory_cc_template
    cc_content = (cc_content.replace("%%component_name%%", component_name)
                            .replace("%%full_namespace%%", full_namespace)
                            .replace("%%ns_begin%%", ns_begin)
                            .replace("%%ns_end%%", ns_end)
                            .replace("%%ns_indent%%", ns_indent)
                            .replace("%%factory_doxygen%%", factory_doxygen))
    return cc_content


def generate_message_files(package, message_descriptor):
    """Given a MessageDescriptor, get required info and generate two headers
    for this message
    @param message_descriptor MessageDescriptor
    @returns tuple
        api_header string with C++ code for api class
        api_source string with C++ code for api implementation
        storage_header string with c++ code for storage class
    """
    # TODO nested types
    nested_types = []
    enumerations = []
    simple_fields = []

    # Pull nested messages out of message
    for nested_descriptor in message_descriptor.nested_type:
        # TODO
        sys.stderr.write("[" + nested_descriptor.name + "]\n")

    # Pull enumerations out of message
    for enum_descriptor in message_descriptor.enum_type:
        enum = {}
        enum["name"] = enum_descriptor.name
        enum["fields"] = []
        for value_descriptor in enum_descriptor.value:
            field = {}
            field["name"] = value_descriptor.name
            field["number"] = value_descriptor.number
            enum["fields"].append(field)
        enumerations.append(enum)

    # Pull simple fields out of the message
    for field_descriptor in message_descriptor.field:
        if field_descriptor.type == FieldDescriptor.TYPE_MESSAGE:
            # Complex/Nested type
            if field_descriptor.type_name in known_nested_types:
                # Swap complex type for a simple type
                field = copy.deepcopy(
                    known_nested_types[field_descriptor.type_name])
                field["name"] = field_descriptor.name
                simple_fields.append(field)
            else:
                sys.stderr.write("TODO nested messages")
                sys.stderr.write("Unknown type " + repr(field_descriptor))
                sys.exit(42)
        elif FieldDescriptor.TYPE_ENUM == field_descriptor.type:
            field = {}
            field["space"] = " "
            field["include"] = ""
            field["name"] = field_descriptor.name
            field["type"] = field_descriptor.type_name.replace(".", "::")
            field["default"] = "static_cast<" + field["type"] + ">(0)"
            simple_fields.append(field)
        else:
            # Simple type
            field = {}
            field["space"] = " "
            field["include"] = ""
            field["name"] = field_descriptor.name
            field["type"] = simple_types_to_cpp[field_descriptor.type]
            default = field_descriptor.default_value
            if ( FieldDescriptor.TYPE_STRING == field_descriptor.type or
                    FieldDescriptor.TYPE_BYTES == field_descriptor.type ):
                field["default"] = '"' + default + '"'
            else:
                field["default"] = default
            simple_fields.append(field)

    # Generate code with the information gathered
    component_name = message_descriptor.name

    api_header, api_source = generate_api_files(package,
            component_name, simple_fields, enumerations)

    storage_header = generate_storage_header(package,
            component_name, simple_fields)

    return api_header, api_source, storage_header


def generate_code(request, response):
    """Given a CodeGeneratorRequest and CodeGeneratorResponse,
    generate C++ code that fulfills the Factory/API/Storage separation
    required of ECS components"""
    # Loop through included protobuf fields
    for proto_file in request.proto_file:
        # Support only one top-level message per file
        if len(proto_file.message_type) != 1:
            sys.stderr.write("Must be exactly one top-level message per file")
            sys.exit(42)

        message_descriptor = proto_file.message_type[0]
        component_name = message_descriptor.name

        api_header, api_source, storage_header = generate_message_files(
                proto_file.package, message_descriptor)

        factory_cc = generate_factory_cc(proto_file.package, component_name)

        base_filename = proto_file.name.split(".")[0]

        api_hh_file = response.file.add()
        api_hh_file.name = base_filename + ".api.hh"
        api_hh_file.content = api_header

        api_cc_file = response.file.add()
        api_cc_file.name = base_filename + ".api.cc"
        api_cc_file.content = api_source

        storage_hh_file = response.file.add()
        storage_hh_file.name = base_filename + ".storage.hh"
        storage_hh_file.content = storage_header

        factory_cc_file = response.file.add()
        factory_cc_file.name = base_filename + ".factory.cc"
        factory_cc_file.content = factory_cc



if __name__ == '__main__':
    # Read request message from stdin
    data = sys.stdin.read()

    # Parse request
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Create response
    response = plugin.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Serialise response message
    output = response.SerializeToString()

    # Write to stdout
    sys.stdout.write(output)
