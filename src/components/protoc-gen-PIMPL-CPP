#!/usr/bin/env python
#
# Copyright (C) 2017 Open Source Robotics Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import os
import sys


try:
    from google.protobuf.compiler import plugin_pb2 as plugin
    from google.protobuf.descriptor import FieldDescriptor
except ImportError:
    sys.stderr.write("""\n\nNeed python protobuf libraries:
        Do `pip install protobuf` or `apt install python-protobuf`\n\n""")
    raise


class Message(object):
    """
    Represents a protobuf message
    """
    def __init__(self):
        self.package = None
        self.name = None
        self.fields = []
        self.oneofs = []
        self.nested_enum = []
        self.nested_msgs = []


class Oneof(object):
    """
    Oneof is a union of fields
    within an object
    """
    def __init__(self):
        self.package = None
        self.name = None
        self.fields = []

    def ApiName(self):
        return self.name + "API"


class Field(object):
    """
    Represents a field in a message
    """
    def __init__(self):
        self.name = None
        self.type = None
        self.default = None
        self.includes = set()
        self.oneof_index = None
        self.is_substituted = False
        self.is_repeated = False
        self.is_complex = False

    @classmethod
    def FromDescriptor(cls, field_descriptor):
        field = cls()
        field.name = field_descriptor.name
        if FieldDescriptor.LABEL_REPEATED == field_descriptor.label:
            field.is_repeated = True
            field.includes.add("vector")

        if field_descriptor.type == FieldDescriptor.TYPE_MESSAGE:
            # Complex/Nested type
            if field_descriptor.type_name in known_complex_types:
                # Substitute field for a known ignition type
                known_type = known_complex_types[field_descriptor.type_name]
                field.type = known_type["type"]
                field.includes.update(known_type["include"])
                field.is_substituted = True
            else:
                field.type = field_descriptor.type_name.replace(".", "::")
                field.is_complex = True
        elif FieldDescriptor.TYPE_ENUM == field_descriptor.type:
            field.type = field_descriptor.type_name.replace(".", "::")
            field.default = "static_cast<" + field.type + ">(0)"
        else:
            # Simple type
            field.type = simple_types_to_cpp[field_descriptor.type]
            if field_descriptor.HasField("default_value"):
                field.default = field_descriptor.default_value
                if (FieldDescriptor.TYPE_STRING == field_descriptor.type or
                        FieldDescriptor.TYPE_BYTES == field_descriptor.type):
                    field.default = '"' + field.default + '"'

        if field_descriptor.HasField("oneof_index"):
            field.oneof_index = field_descriptor.oneof_index
        return field


class Enum(object):
    """
    Represents an enumeration
    """
    def __init__(self):
        self.type = "uint32_t"
        self.includes = set(["cstdint"])
        self.fields = []

    @classmethod
    def FromDescriptor(cls, enum_descriptor):
        enum = cls()
        enum.name = enum_descriptor.name
        for value_descriptor in enum_descriptor.value:
            field = EnumField()
            field.name = value_descriptor.name
            field.number = value_descriptor.number
            enum.fields.append(field)
        return enum


class EnumField(object):
    """
    Represents one field in an enumeration
    """
    def __init__(self):
        self.name = None
        self.number = None


# nested types that can be swapped for simple types
known_complex_types = {
        ".gazebo.components.Vector3d": {
            "type": "ignition::math::Vector3d",
            "file": "gazebo/components/Vector3d.proto",
            "include": set(["ignition/math/Vector3.hh"]),
            "default": None,
            },
        ".gazebo.components.Quaterniond": {
            "type": "ignition::math::Quaterniond",
            "file": "gazebo/components/Quaterniond.proto",
            "include": set(["ignition/math/Quaternion.hh"]),
            "default": None,
            },
        ".gazebo.components.Pose3d": {
            "type": "ignition::math::Pose3d",
            "file": "gazebo/components/Pose3d.proto",
            "include": set(["ignition/math/Pose3.hh"]),
            "default": None,
            },
        ".gazebo.components.Matrix3d": {
            "type": "ignition::math::Matrix3d",
            "file": "gazebo/components/Matrix3d.proto",
            "include": set(["ignition/math/Matrix3.hh"]),
            "default": None,
            },
        }


# Known complex types get swapped out, no need to include api files for them
ignore_dependencies = [kct["file"] for kct in known_complex_types.values()]


# Map protobuf simple types to c++ types
simple_types_to_cpp = {
        FieldDescriptor.TYPE_DOUBLE: "double",
        FieldDescriptor.TYPE_FLOAT: "float",
        FieldDescriptor.TYPE_INT64: "int64_t",
        FieldDescriptor.TYPE_UINT64: "uint64_t",
        FieldDescriptor.TYPE_INT32: "int32_t",
        FieldDescriptor.TYPE_FIXED64: "uint64_t",
        FieldDescriptor.TYPE_FIXED32: "uint32_t",
        FieldDescriptor.TYPE_BOOL: "bool",
        FieldDescriptor.TYPE_STRING: "std::string",
        FieldDescriptor.TYPE_BYTES: "std::string",
        FieldDescriptor.TYPE_UINT32: "uint32_t",
        FieldDescriptor.TYPE_SFIXED32: "int32_t",
        FieldDescriptor.TYPE_SFIXED64: "int64_t",
        FieldDescriptor.TYPE_SINT32: "int32_t",
        FieldDescriptor.TYPE_SINT64: "int64_t",
        }


def get_template(name):
    """Returns contents of template"""
    file_path = os.path.dirname(os.path.realpath(__file__))
    with open(file_path + "/templates/" + name, "r") as fin:
        return fin.read()


def populate_template(template, **kwargs):
    """Uses keyword arugments to do template substitutions"""
    populated = template
    for key, value in kwargs.items():
        populated = populated.replace("%%{key}%%".format(key=key), str(value))
    return populated


tmpl_factory_hh = get_template("Factory.hh.in")
tmpl_factory_cc = get_template("Factory.cc.in")
tmpl_api_hh = get_template("Api.hh.in")
tmpl_api_cc = get_template("Api.cc.in")
tmpl_class_decl = get_template("ApiNestedClassDecl.hh.in")
tmpl_class_def = get_template("ApiNestedClassDef.cc.in")
tmpl_storage_hh = get_template("Storage.hh.in")
tmpl_storage_decl = get_template("StorageClassDecl.hh.in")
tmpl_storage_union_decl = get_template("StorageClassUnion.hh.in")
tmpl_declaration = get_template("ApiDecl.hh.in")
tmpl_definition = get_template("ApiDef.cc.in")
tmpl_repeated_decl = get_template("ApiRepeatedDecl.hh.in")
tmpl_repeated_def = get_template("ApiRepeatedDef.cc.in")
tmpl_oneof_decl = get_template("ApiOneofDecl.hh.in")
tmpl_oneof_def = get_template("ApiOneofDef.cc.in")
tmpl_complex_decl = get_template("ApiComplexDecl.hh.in")
tmpl_complex_def = get_template("ApiComplexDef.cc.in")
tmpl_complex_repeated_decl = get_template("ApiComplexRepeatedDecl.hh.in")
tmpl_complex_repeated_def = get_template("ApiComplexRepeatedDef.cc.in")
tmpl_complex_oneof_decl = get_template("ApiComplexOneofDecl.hh.in")
tmpl_complex_oneof_def = get_template("ApiComplexOneofDef.cc.in")
tmpl_field = get_template("StorageField.cc.in")
tmpl_field_repeated = get_template("StorageFieldRepeated.cc.in")
tmpl_field_with_default = get_template("StorageFieldWithDefault.cc.in")
tmpl_include = get_template("Include.hh.in")
tmpl_enum = get_template("Enum.hh.in")
tmpl_enum_field = get_template("EnumField.hh.in")
tmpl_union_field_copy = get_template("UnionFieldCopy.hh.in")
tmpl_union_field_destruct = get_template("UnionFieldDestruct.hh.in")


def generate_enum(tmpl_enum, indent, enum):
    """Generate a single enum given a dict of values
    @param tmpl_enum template to put enum fields in
    @param indent is whitespace to indent the enum
    @param enum instance of Enum
    @returns a string with the generted C++ code
    """
    # Generate code for individual values in enum
    gen_fields = []
    for field in enum.fields:
        gen_fields.append(populate_template(tmpl_enum_field, ns_indent=indent,
                                            field_name=field.name,
                                            field_number=field.number))
    gen_fields = "".join(gen_fields)
    # combine value into a larger enum type
    gen_enum_hh = tmpl_enum
    gen_enum_hh = populate_template(tmpl_enum, ns_indent=indent,
                                    enum_name=enum.name,
                                    enum_fields=gen_fields)
    return gen_enum_hh


def generate_namespace(package):
    """Generates odd bits of C++ code based on a period delimited string
    @returns tuple
        ns_indent (whitespace to indent code)
        full_namespace (c++ namespace using ::)
        ns_begin (start of namespace block)
        ns_end (end of namespace block)
    """
    # discard empty pieces (leading dot)
    namespaces = [piece for piece in package.split(".") if piece]
    full_namespace = "::".join(namespaces)
    ns_indent = "  " * len(namespaces)
    ns_begin = ""
    ns_end = ""
    for x, ns in enumerate(namespaces):
        indent = "  " * x
        ns_begin += "\n{indent}namespace {ns}\n{indent}{{".format(
                indent=indent, ns=ns)
        ns_end = "{indent}}}\n".format(indent=indent) + ns_end
    return (ns_indent, full_namespace, ns_begin, ns_end)


def generate_apis(package, class_name, fields):
    """Generates C++ code for pieces of a class
    @param package a dot delimited string
    @param class_name string name of class
    @param fields list of instances of Field
    @returns dict
        api_definitions list with C++ api defintions
        api_declarations list with C++ api declarations
        hh_includes set with C++ includes
    """
    # generate c++ namespace from protobuf package
    (ns_indent, full_namespace,
     ns_begin, ns_end) = generate_namespace(package)

    api_definitions = []
    api_declarations = []
    hh_includes = set()

    # Generate code for simple fields
    for field in fields:
        declaration = None
        definition = None

        if field.is_complex:
            if field.is_repeated:
                declaration = tmpl_complex_repeated_decl
                definition = tmpl_complex_repeated_def
            elif field.oneof_index is not None:
                declaration = tmpl_complex_oneof_decl
                definition = tmpl_complex_oneof_def
            else:
                declaration = tmpl_complex_decl
                definition = tmpl_complex_def
        else:
            if field.is_repeated:
                declaration = tmpl_repeated_decl
                definition = tmpl_repeated_def
            elif field.oneof_index is not None:
                declaration = tmpl_oneof_decl
                definition = tmpl_oneof_def
            else:
                declaration = tmpl_declaration
                definition = tmpl_definition

        api_declarations.append(populate_template(
                declaration, field_type=field.type, field_name=field.name,
                ns_indent=ns_indent, class_name=class_name))

        api_definitions.append(populate_template(
                definition, field_type=field.type, field_name=field.name,
                ns_indent=ns_indent, full_namespace=full_namespace,
                class_name=class_name))

        for include in field.includes:
            hh_includes.add(populate_template(tmpl_include, include=include))

    return {"api_definitions": api_definitions,
            "api_declarations": api_declarations,
            "hh_includes": hh_includes}


def generate_api_partial(tmpl_decl, tmpl_def, msg):
    """Generates C++ code for API class for a given message
    @param tmpl_decl class declaration template
    @param tmpl_def class definition template
    @param msg Message instance
    @returns dict
        hh_includes set of headers that need to be included
        class_decl string C++ code with class declaration
        class_def string C++ code with class declaration
    """
    # generate c++ namespace from protobuf package
    (ns_indent, full_namespace,
     ns_begin, ns_end) = generate_namespace(msg.package)

    # Generate code for enum types
    enum_types = []
    for enum in msg.nested_enum:
        enum_types.append(generate_enum(tmpl_enum, ns_indent, enum))

    # Generate code for APIs
    class_pieces = generate_apis(msg.package, msg.name, msg.fields)

    inline_decl = []
    inline_def = []
    hh_includes = class_pieces["hh_includes"]

    for nested_msg in msg.nested_msgs:
        # Recursively generate nested messages
        nested_partial = generate_api_partial(
                tmpl_class_decl, tmpl_class_def, nested_msg)
        hh_includes.update(nested_partial["hh_includes"])
        inline_decl.append(nested_partial["class_decl"])
        inline_def.append(nested_partial["class_def"])

    # Generate code for oneofs
    for oneof in msg.oneofs:
        (oneof_ns_indent, oneof_ns, oneof_ns_begin,
         oneof_ns_end) = generate_namespace(oneof.package)
        oneof_pieces = generate_apis(oneof.package, oneof.ApiName(),
                                     oneof.fields)
        hh_includes.update(oneof_pieces["hh_includes"])
        oneof_api_decl = "\n".join(oneof_pieces["api_declarations"])
        oneof_api_def = "\n".join(oneof_pieces["api_definitions"])

        oneof_decl = populate_template(
                tmpl_class_decl, class_name=oneof.ApiName(),
                ns_indent=oneof_ns_indent, api_declarations=oneof_api_decl,
                inline_declarations="", enumerations="")

        oneof_def = populate_template(
                tmpl_class_def, class_name=oneof.ApiName(),
                ns_indent=oneof_ns_indent, api_definitions=oneof_api_def,
                inline_definitions="")

        inline_decl.append(oneof_decl)
        inline_def.append(oneof_def)

    api_definitions = "\n".join(class_pieces["api_definitions"])
    api_declarations = "\n".join(class_pieces["api_declarations"])
    inline_decl = "\n".join(inline_decl)
    inline_def = "\n".join(inline_def)
    enum_types = "\n".join(enum_types)

    # Put all content together
    hh_content = populate_template(
            tmpl_decl, class_name=msg.name, inline_declarations=inline_decl,
            api_declarations=api_declarations, ns_indent=ns_indent,
            enumerations=enum_types)

    cc_content = populate_template(
            tmpl_def, class_name=msg.name, api_definitions=api_definitions,
            full_namespace=full_namespace, ns_indent=ns_indent,
            inline_definitions=inline_def)

    return {"hh_includes": hh_includes,
            "class_decl": hh_content,
            "class_def": cc_content}


def generate_api_files(dependency, msg):
    """Generates header and source file for API
    @param dependency iterable of strings of protofiles
    @param msg Message() instance for protobuf
    @returns tuple
        string with header file
        string with source file
    """
    # generate c++ namespace from protobuf package
    (ns_indent, full_namespace,
     ns_begin, ns_end) = generate_namespace(msg.package)

    hh_includes = set()

    include_guard = "_".join(msg.package.split("."))
    include_guard = "_".join([include_guard, msg.name]).upper()

    # Includes for .proto file level dependencies
    for dep in dependency:
        # discard ".proto"
        pieces = dep.split(".")[:-1]
        include = "/".join(pieces) + ".api.hh"
        hh_includes.add(populate_template(tmpl_include, include=include))

    partial_cpp = generate_api_partial(tmpl_api_hh, tmpl_api_cc, msg)
    hh_includes.update(partial_cpp["hh_includes"])
    hh_includes = "".join(hh_includes)

    # Put all content together
    hh_content = populate_template(partial_cpp["class_decl"],
                                   full_namespace=full_namespace,
                                   ns_begin=ns_begin, ns_end=ns_end,
                                   includes=hh_includes,
                                   include_guard=include_guard)

    cc_content = populate_template(partial_cpp["class_def"],
                                   component_name=msg.name,
                                   full_namespace=full_namespace,
                                   ns_begin=ns_begin, ns_end=ns_end)
    return hh_content, cc_content


def generate_storage_fields(class_name, fields):
    """Generates code for storage fields
    @param class_name name of storage class fields are in
    @fields list of instances of Field
    returns string of generated fields
    """
    storage_fields = []
    for field in fields:
        tmpl = None
        if field.is_repeated:
            tmpl = tmpl_field_repeated
        elif field.default is not None:
            tmpl = tmpl_field_with_default
        else:
            tmpl = tmpl_field

        field_type = field.type
        if field.is_complex:
            field_type = field.type + "Storage"

        storage_fields.append(populate_template(
            tmpl, field_default=field.default, field_type=field_type,
            field_name=field.name))
    return "\n".join(storage_fields)


def generate_storage_oneof(oneof):
    """Generates a storage class for a oneof
    @param oneof instance of Oneof
    returns string of generated storage class
    """
    # Special storage class for oneof types
    (oneof_ns_indent, oneof_ns, oneof_ns_begin,
     oneof_ns_end) = generate_namespace(oneof.package)
    oneof_fields = generate_storage_fields(oneof.ApiName(), oneof.fields)

    # Generate constructors/destructor
    copiers = []
    destructors = []
    for field in oneof.fields:
        copiers.append(populate_template(
                tmpl_union_field_copy, class_name=oneof.ApiName(),
                full_namespace=oneof_ns, field_name=field.name))
        destructors.append(populate_template(
                tmpl_union_field_destruct, class_name=oneof.ApiName(),
                full_namespace=oneof_ns, field_name=field.name))
    copiers = "\n".join(copiers)
    destructors = "\n".join(destructors)

    # Gen most of the code
    oneof_partial = populate_template(
            tmpl_storage_union_decl, udestruct=destructors, ucopy=copiers,
            class_name=oneof.ApiName(), full_namespace=oneof_ns,
            storage_fields=oneof_fields)

    # One last bit, generate implicit enum
    oneof_enum = Enum()
    oneof_enum.name = oneof.name
    num = 10
    for field in oneof.fields:
        enum_field = EnumField()
        enum_field.name = "".join(
                ["enumval_", oneof.ApiName(), "_", field.name])
        enum_field.number = num
        num += 1
        oneof_enum.fields.append(enum_field)
    return generate_enum(oneof_partial, oneof_ns_indent, oneof_enum)


def generate_storage_class(template, msg):
    """Generates storage class for a nested definition
    @param template c++ template to use
    @param msg Message instance to generate storage from
    @returns string generated storage class
    """
    (ns_indent, full_namespace,
     ns_begin, ns_end) = generate_namespace(msg.package)

    inline_storage = []
    for nested_msg in msg.nested_msgs:
        # Recursively generate code for nested messages
        inline_storage.append(generate_storage_class(tmpl_storage_decl,
                                                     nested_msg))

    # Inline storage for oneof
    for oneof in msg.oneofs:
        inline_storage.append(generate_storage_oneof(oneof))

    inline_storage = "\n".join(inline_storage)

    storage_fields = generate_storage_fields(msg.name, msg.fields)

    return populate_template(
            template, class_name=msg.name, full_namespace=full_namespace,
            inline_storage=inline_storage, storage_fields=storage_fields)


def generate_storage_header(dependency, msg):
    """Generates header for storage class
    @param dependency iterable of strings of protofiles
    @param msg Message instance
    @returns string with header file
    """
    # generate c++ namespace from protobuf package
    (ns_indent, full_namespace,
     ns_begin, ns_end) = generate_namespace(msg.package)

    partial_class = generate_storage_class(tmpl_storage_hh, msg)

    includes = set()
    for dep in dependency:
        # discard ".proto"
        pieces = dep.split(".")[:-1]
        include = "/".join(pieces) + ".storage.hh"
        includes.add(populate_template(tmpl_include, include=include))
    includes = "".join(includes)

    include_guard = "_".join(msg.package.split("."))
    include_guard = "_".join([include_guard, msg.name]).upper()

    return populate_template(partial_class, includes=includes,
                             include_guard=include_guard)


def generate_factory_files(package, component_name):
    """Generates cc file with factory class
    @param package string dot delimited
    @param component_name string name of component
    @returns string content of factory .cc file
    """
    (ns_indent, full_namespace,
     ns_begin, ns_end) = generate_namespace(package)

    include_guard = "_".join(package.split("."))
    include_guard = "_".join([include_guard, component_name]).upper()

    factory_hh = populate_template(
            tmpl_factory_hh, component_name=component_name,
            full_namespace=full_namespace, ns_begin=ns_begin, ns_end=ns_end,
            ns_indent=ns_indent, include_guard=include_guard)

    factory_cc = populate_template(
            tmpl_factory_cc, component_name=component_name,
            full_namespace=full_namespace, ns_begin=ns_begin, ns_end=ns_end,
            ns_indent=ns_indent)
    return factory_hh, factory_cc


def gather_message_info(package, message_descriptor):
    """Given a MessageDescriptor, pull out the info we need and put it into
    another representation that's easier to generate code from
    @param package string dot delimited
    @param message_descriptor MessageDescriptor
    @returns Message instance
    """
    msg = Message()
    msg.name = message_descriptor.name

    if package and package[0] != ".":
        package = "." + package
    msg.package = package

    # Recursively get info from nested messages
    for nested_descriptor in message_descriptor.nested_type:
        nested_package = ".".join([package, msg.name])
        msg.nested_msgs.append(gather_message_info(
                nested_package, nested_descriptor))

    # Pull enumerations out of message
    for enum_descriptor in message_descriptor.enum_type:
        enum = Enum.FromDescriptor(enum_descriptor)
        msg.nested_enum.append(enum)

    # Pull info about Oneof's from message
    for oneof_descriptor in message_descriptor.oneof_decl:
        oneof = Oneof()
        oneof.name = oneof_descriptor.name
        oneof.package = ".".join([package, msg.name])
        msg.oneofs.append(oneof)
        # Add a complex field that returns a calss to access the oneof
        field = Field()
        field.name = oneof.name
        field.is_complex = True
        dot_type = ".".join([oneof.package, oneof.ApiName()])
        field.type = dot_type.replace(".", "::")
        msg.fields.append(field)

    # Pull info about fields from the message
    for field_descriptor in message_descriptor.field:
        field = Field.FromDescriptor(field_descriptor)

        if field.oneof_index is not None:
            msg.oneofs[field.oneof_index].fields.append(field)
        else:
            msg.fields.append(field)

    return msg


def generate_message_files(dependency, package, message_descriptor):
    """Given a MessageDescriptor, get required info and generate two headers
    for this message
    @param dependency iterable of strings of imported files
    @param package string dot delimited
    @param message_descriptor MessageDescriptor
    @returns tuple
        api_header string with C++ code for api class
        api_source string with C++ code for api implementation
        storage_header string with c++ code for storage class
    """
    msg_info = gather_message_info(package, message_descriptor)

    # Don't create includes for substituted types
    dependency = [dep for dep in dependency if dep not in ignore_dependencies]

    # Generate code with the information gathered
    api_header, api_source = generate_api_files(dependency, msg_info)
    storage_header = generate_storage_header(dependency, msg_info)

    return api_header, api_source, storage_header


def generate_code(request, response):
    """Given a CodeGeneratorRequest and CodeGeneratorResponse,
    generate C++ code that fulfills the Factory/API/Storage separation
    required of ECS components"""
    # Loop through included protobuf fields
    for proto_file in request.proto_file:
        # Support only one top-level message per file
        if len(proto_file.message_type) != 1:
            sys.stderr.write("Must be exactly one top-level message per file")
            sys.exit(42)

        message_descriptor = proto_file.message_type[0]
        component_name = message_descriptor.name

        api_header, api_source, storage_header = generate_message_files(
                proto_file.dependency, proto_file.package, message_descriptor)

        factory_hh, factory_cc = generate_factory_files(proto_file.package,
                                                        component_name)

        base_filename = proto_file.name.split(".")[0]

        api_hh_file = response.file.add()
        api_hh_file.name = base_filename + ".api.hh"
        api_hh_file.content = api_header

        api_cc_file = response.file.add()
        api_cc_file.name = base_filename + ".api.cc"
        api_cc_file.content = api_source

        storage_hh_file = response.file.add()
        storage_hh_file.name = base_filename + ".storage.hh"
        storage_hh_file.content = storage_header

        factory_cc_file = response.file.add()
        factory_cc_file.name = base_filename + ".factory.hh"
        factory_cc_file.content = factory_hh

        factory_cc_file = response.file.add()
        factory_cc_file.name = base_filename + ".factory.cc"
        factory_cc_file.content = factory_cc


if __name__ == '__main__':
    # Read request message from stdin
    try:
        data = sys.stdin.buffer.read()
    except AttributeError:
        data = sys.stdin.read()

    # Parse request
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Create response
    response = plugin.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Serialise response message
    output = response.SerializeToString()

    # Write to stdout
    try:
        sys.stdout.buffer.write(output)
    except AttributeError:
        sys.stdout.write(output)
