/*
 * Copyright (C) 2017 Open Source Robotics Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

/* ***********************************
 * ******** GENERATED FILE ***********
 * *      Do not edit directly       *
 * ***********************************
 * This file was generated on %%gen_date%% using the command
 * %%gen_cmd%%
 * from the file
 * %%gen_file%%
 * ***********************************
 */

#include <ignition/common/PluginMacros.hh>
#include <gazebo/ecs/Component.hh>

#include "%%class_name%%.api.hh"
#include "%%class_name%%.storage.hh"

namespace generated_ns = %%full_namespace%%;
using namespace generated_ns;


//////////////////////////////////////////////////
static gazebo::ecs::ComponentType g%%class_name%%ComponentType = gazebo::ecs::NO_COMPONENT;

//////////////////////////////////////////////////
%%class_name%%::%%class_name%%()
  : dataPtr(new %%class_name%%Storage)
{
}

//////////////////////////////////////////////////
%%class_name%%::%%class_name%%(const %%class_name%% &_rhs)
{
  this->dataPtr.reset(new %%class_name%%Storage(*(_rhs.dataPtr)));
}

//////////////////////////////////////////////////
%%class_name%%::%%class_name%%(%%class_name%% &&_old)
{
  this->dataPtr.swap(_old.dataPtr);
}

//////////////////////////////////////////////////
%%class_name%% &%%class_name%%::operator=(const %%class_name%% &_rhs)
{
  this->dataPtr.reset(new %%class_name%%Storage(*(_rhs.dataPtr)));
  return *this;
}

//////////////////////////////////////////////////
void %%class_name%%::DeepCopy(const gazebo::ecs::Component &_other)
{
  if (this->ComponentType() == gazebo::ecs::NO_COMPONENT)
  {
    throw gazebo::ecs::NoComponentType();
  }
  if (_other.ComponentType() != this->ComponentType())
  {
    throw gazebo::ecs::NotSameComponentType();
  }

  auto const &other = reinterpret_cast<const %%class_name%%&>(_other);
  this->dataPtr.reset(new %%class_name%%Storage(*(other.dataPtr)));
}

//////////////////////////////////////////////////
void %%class_name%%::Move(gazebo::ecs::Component &_old)
{
  if (this->ComponentType() == gazebo::ecs::NO_COMPONENT)
  {
    throw gazebo::ecs::NoComponentType();
  }
  if (_old.ComponentType() != this->ComponentType())
  {
    throw gazebo::ecs::NotSameComponentType();
  }

  auto &old = reinterpret_cast<%%class_name%%&>(_old);
  this->dataPtr.swap(old.dataPtr);
}

//////////////////////////////////////////////////
%%class_name%%::~%%class_name%%()
{
}

//////////////////////////////////////////////////
const char *%%class_name%%::ComponentName() const
{
  return "%%full_namespace%%::%%class_name%%";
}

//////////////////////////////////////////////////
gazebo::ecs::ComponentType %%class_name%%::ComponentType() const
{
  return g%%class_name%%ComponentType;
}

//////////////////////////////////////////////////
void %%class_name%%::ComponentType(gazebo::ecs::ComponentType _type)
{
  // allow type assignment once per run
  if (g%%class_name%%ComponentType == gazebo::ecs::NO_COMPONENT)
    g%%class_name%%ComponentType = _type;
}

%%inline_definitions%%

%%api_definitions%%

IGN_COMMON_REGISTER_SINGLE_PLUGIN(%%full_namespace%%::%%component_name%%,
    gazebo::ecs::Component)
